# Area Model

## Overview

The XSL-FO area model defines how a formatter transforms a tree of formatting objects into a hierarchical arrangement of rectangular areas that comprise the formatted result. The area model is an abstract framework describing constraints for conforming implementations; it does not prescribe particular algorithms. Understanding the area model is essential for predicting how formatting objects map to rendered output, how areas are positioned, and how stacking and ordering constraints govern layout.

<!-- Source: https://www.w3.org/TR/xslfo20/#area_model -->

## Introduction

<!-- Source: https://www.w3.org/TR/xslfo20/#area-intro -->

The formatter generates an ordered tree called the **area tree**, which describes a geometric structuring of the output medium. The standard tree terms -- child, sibling, parent, descendant, ancestor -- refer to this tree structure. The tree has a root node.

Each area tree node other than the root is called an **area** and is associated with a rectangular portion of the output medium. Areas are not formatting objects; rather, a formatting object generates zero or more rectangular areas, and normally each area is generated by a unique object in the formatting object tree.

The only exceptions to this rule are when several leaf nodes of the formatting object tree are combined to generate a single area (for example, when several characters in sequence generate a single ligature glyph). In all such cases, relevant properties such as `font-family` and `font-size` must be the same for all the generating formatting objects.

An area has a **content-rectangle** (the portion in which its child areas are assigned), and optional **padding** and **border**. The outer bound of the border is the **border-rectangle**, and the outer bound of the padding is the **padding-rectangle**.

Each area has a set of **traits** -- a mapping of names to values, analogous to how elements have attributes and formatting objects have properties. Individual traits are used for rendering the area, for defining constraints on the result of formatting, or both:

- **Formatting traits**: used strictly for formatting purposes or for defining constraints.
- **Rendering traits**: used for rendering.

Traits whose values are copied or derived from a property of the same or a corresponding name are listed in the property index and refinement sections; other traits are listed below.

The semantics of each type of formatting object that generates areas are given in terms of which areas it generates and their place in the area-tree hierarchy. The properties of the formatting object determine what areas are generated and how the formatting object's content is distributed among them.

Traits of an area are either:

- **Directly-derived**: the values are the computed value of a property of the same or a corresponding name on the generating formatting object.
- **Indirectly-derived**: the values are the result of a computation involving the computed values of one or more properties on the generating formatting object, other traits on this area or other interacting areas (ancestors, parent, siblings, and/or children) and/or one or more values constructed by the formatter.

The indirectly-derived traits are: `block-progression-direction`, `inline-progression-direction`, `shift-direction`, `glyph-orientation`, `is-reference-area`, `is-viewport-area`, `left-position`, `right-position`, `top-position`, `bottom-position`, `left-offset`, `top-offset`, `is-first`, `is-last`, `alignment-point`, `area-class`, `start-intrusion-adjustment`, `end-intrusion-adjustment`, `generated-by`, `returned-by`, `folio-number`, `blink`, `underline-score`, `overline-score`, `through-score`, `underline-score-color`, `overline-score-color`, `through-score-color`, `alignment-baseline`, `baseline-shift`, `nominal-font`, `dominant-baseline-identifier`, `actual-baseline-table`, and `script`.

## Rectangular Areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-rect -->

### Area Types

There are two types of areas: **block-areas** and **inline-areas**. These differ according to how they are typically stacked by the formatter. An area can have block-area children or inline-area children as determined by the generating formatting object, but a given area's children must all be of one type. Although block-areas and inline-areas are typically stacked, some areas can be explicitly positioned.

- A **line-area** is a special kind of block-area whose children are all inline-areas.
- A **glyph-area** is a special kind of inline-area which has no child areas, and has a single glyph image as its content.
- An inline-area may have one or two **annotation-areas** containing annotations such as ruby and emphasis dots.

Typical examples: a paragraph rendered by using `fo:block` generates block-areas, and a character rendered by using `fo:character` generates an inline-area (specifically, a glyph-area).

### Common Traits

<!-- Source: https://www.w3.org/TR/xslfo20/#area-common -->

Associated with any area are two directions, derived from the generating formatting object's `writing-mode` and `reference-orientation` properties:

- **block-progression-direction**: the direction for stacking block-area descendants.
- **inline-progression-direction**: the direction for stacking inline-area descendants.
- **shift-direction**: present on inline-areas, refers to the direction in which baseline shifts are applied.
- **glyph-orientation**: defines the orientation of glyph-images in the rendered result.

If the `reference-orientation` for an area is 0, then the top, bottom, left, and right edges of the content are parallel to those of the area's parent and consistent with them. Otherwise the edges are rotated from those of the area's parent as described in the `reference-orientation` property definition.

The Boolean trait **is-reference-area** determines whether an area establishes a coordinate system for specifying indents. An area for which this trait is `true` is called a **reference-area**. Only a reference-area may have a block-progression-direction different from that of its parent. A reference-area may be either a block-area or an inline-area.

The Boolean trait **is-viewport-area** determines whether an area establishes an opening through which its descendant areas can be viewed, and can be used to present clipped or scrolled material (for example, in printing applications where bleed and trim is desired). An area for which this trait is `true` is called a **viewport-area**. A viewport-area also has the value `true` for the `is-reference-area` trait.

A common construct is a **viewport/reference pair**: a viewport-area V and a block-area reference-area R, where R is the sole child of V and where the start-edge and end-edge of the content-rectangle of R are parallel to the start-edge and end-edge of the content-rectangle of V.

Each area has the traits **top-position**, **bottom-position**, **left-position**, and **right-position** which represent the distance from the edges of its content-rectangle to the like-named edges of the nearest ancestor reference-area (or the page-viewport-area in the case of areas generated by descendants of formatting objects whose `absolute-position` is `fixed`). The **left-offset** and **top-offset** determine the amount by which a relatively-positioned area is shifted for rendering.

The **block-progression-dimension** and **inline-progression-dimension** of an area represent the extent of the content-rectangle of that area in each of the two relative directions.

Other traits include:

- **is-first** and **is-last**: Boolean traits indicating the order in which areas are generated and returned by a given formatting object. `is-first` is `true` for the first area (or only area) generated and returned, and `is-last` is `true` for the last area (or only area).
- **space-before**, **space-after**, **space-start**, and **space-end**: the amount of space outside the border-rectangle (some of these may be required to be zero on certain classes of area).
- **padding-before**, **padding-after**, **padding-start**, and **padding-end**: the thickness of each of the four sides of the padding.
- **border-before**, etc.: the style, thickness, and color of each of the four sides of the border.
- **background-color**, **background-image**, and other background traits.
- **nominal-font**: determined by the font properties and the character descendants of the area's generating formatting object.

Unless otherwise specified, the traits of a formatting object are present on each of its generated areas, and with the same value. The `id` trait is computed for formatting objects but is not present on areas.

### Geometric Definitions

<!-- Source: https://www.w3.org/TR/xslfo20/#area-geo -->

The **content-rectangle** is the rectangle bounding the inside of the padding and is used to describe the constraints on the positions of descendant areas. It is possible that marks from descendant glyphs or other areas may appear outside the content-rectangle.

The **allocation-rectangle** of an area is used to describe the constraints on the position of the area within its parent area.

**For an inline-area**, the allocation-rectangle is either:

- The **normal-allocation-rectangle**: extends to the content-rectangle in the block-progression-direction and to the border-rectangle in the inline-progression-direction.
- The **large-allocation-rectangle**: the border-rectangle.

Unless otherwise specified, the allocation-rectangle for an area is the normal-allocation-rectangle.

**For a block-area**, the allocation-rectangle extends to the border-rectangle in the block-progression-direction and outside the content-rectangle in the inline-progression-direction by an amount equal to the `end-indent`, and in the opposite direction by an amount equal to the `start-indent`.

The inclusion of space outside the border-rectangle of a block-area in the inline-progression-direction does not affect placement constraints, and is intended to promote compatibility with the CSS box model.

**Edge designations** of a rectangle:

- **before-edge**: the edge occurring first in the block-progression-direction and perpendicular to it.
- **after-edge**: the edge opposite the before-edge.
- **start-edge**: the edge occurring first in the inline-progression-direction and perpendicular to it.
- **end-edge**: the edge opposite the start-edge.

The content-rectangle of an area uses the inline-progression-direction and block-progression-direction of that area; but the border-rectangle, padding-rectangle, and allocation-rectangle use the directions of its parent area. Thus the edges designated for the content-rectangle may not correspond to the same-named edges on the padding-, border-, and allocation-rectangles. This is important in the case of nested areas with different writing-modes or reference-orientation.

Each inline-area has an **alignment-point** determined by the formatter, on the start-edge of its allocation-rectangle; for a glyph-area, this is a point on the start-edge of the glyph on its alignment baseline. This is script-dependent and does not necessarily correspond to the (0,0) coordinate point used for the data describing the glyph shape.

### Tree Ordering

<!-- Source: https://www.w3.org/TR/xslfo20/#area-treeorder -->

In the area tree, the set of areas with a given parent is ordered. The terms **initial**, **final**, **preceding**, and **following** refer to this ordering.

In any ordered tree, this sibling order extends to an ordering of the entire tree in at least two ways:

- **Pre-order traversal order**: the children of each node (their order unchanged relative to one another) follow the node, but precede any following siblings of the node or of its ancestors.
- **Post-order traversal order**: the children of each node precede the node, but follow any preceding siblings of the node or of its ancestors.

"Preceding" and "following", when applied to non-siblings, depend on the extension order used, which must be specified. However, in either of these given orders, the leaves of the tree (nodes without children) are unambiguously ordered.

### Stacking Constraints

<!-- Source: https://www.w3.org/TR/xslfo20/#area-stackcon -->

This section defines **block-stacking constraints** and **inline-stacking constraints** involving areas. These are ordered relations: if A and B have a stacking constraint, it does not necessarily mean that B and A have a stacking constraint. These definitions are recursive in nature. The intention is to identify areas at any level of the tree which may have only space between them.

The `area-class` trait is an enumerated value:

- `xsl-normal`: a **normal** area stacked with other areas in sequence.
- `xsl-footnote`, `xsl-before-float`, `xsl-fixed`: **page-level-out-of-line** areas whose placement is controlled by the `fo:page-sequence` ancestor.
- `xsl-side-float`, `xsl-absolute`: **reference-level-out-of-line** areas whose placement is controlled by the formatting object generating the relevant reference-area.
- `xsl-anchor`: **anchor** areas whose placement is arbitrary and does not affect stacking.

Areas with area-class `xsl-normal`, `xsl-footnote`, or `xsl-before-float` are defined to be **stackable**, indicating that they are supposed to be properly stacked.

#### Block-stacking constraints

If P is a block-area, then there is a **fence preceding** P if P is a reference-area or if the `border-before-width` or padding-before-width of P are non-zero. Similarly, there is a **fence following** P if P is a reference-area or if the `border-after-width` or padding-after-width of P are non-zero.

If A and B are stackable areas, and S is a sequence of space-specifiers, then A and B have block-stacking constraint S if any of the following conditions holds:

1. B is a block-area which is the first normal child of A, and S is the sequence consisting of the `space-before` of B.
2. A is a block-area which is the last normal child of B, and S is the sequence consisting of the `space-after` of A.
3. A and B are both block-areas, and either:
   - (a) B is the next stackable sibling area of A, and S is the sequence consisting of the `space-after` of A and the `space-before` of B;
   - (b) B is the first normal child of a block-area P, B is not a line-area, there is no fence preceding P, A and P have a block-stacking constraint S', and S consists of S' followed by the `space-before` of B;
   - (c) A is the last normal child of a block-area P, A is not a line-area, there is no fence following P, P and B have a block-stacking constraint S'', and S consists of the `space-after` of A followed by S'';
   - (d) A has a block-stacking constraint S' with a block-area E, E has a block-stacking constraint S'' with B, E is **empty** (i.e., it has zero border, padding, and block-progression-dimension, and no normal children), and S consists of S' followed by S''.

When A and B have a block-stacking constraint, the **adjacent edges** of A and B are an ordered pair recursively defined as:

- Case 1: the before-edge of the content-rectangle of A and the before-edge of the allocation-rectangle of B.
- Case 2: the after-edge of the allocation-rectangle of A and the after-edge of the content-rectangle of B.
- Case 3a: the after-edge of the allocation-rectangle of A and the before-edge of the allocation-rectangle of B.
- Case 3b: the first of the adjacent edges of A and P, and the before-edge of the allocation-rectangle of B.
- Case 3c: the after-edge of the allocation-rectangle of A and the second of the adjacent edges of P and B.
- Case 3d: the first of the adjacent edges of A and E, and the second of the adjacent edges of E and B.

#### Inline-stacking constraints

The definition for inline-stacking constraints parallels that for block-stacking constraints, with the additional complication that there may be a stacking constraint between inline-areas stacked in opposite inline-progression-directions (relevant for bidirectional text). This is not an issue for block-stacking constraints because a block-area which is not a reference-area may not have a block-progression-direction different from that of its parent.

If P and Q have an inline-stacking constraint, then P has a **fence preceding** Q if P is a reference-area or has non-zero border-width or padding-width at the first adjacent edge of P and Q. Similarly, Q has a **fence following** P if Q is a reference-area or has non-zero border-width or padding-width at the second adjacent edge of P and Q.

If A and B are normal areas, and S is a sequence of space-specifiers, then A and B have inline-stacking constraint S if any of the following conditions holds:

1. A is an inline-area or line-area, B is an inline-area which is the first normal child of A, and S is the sequence consisting of the `space-start` of B.
2. B is an inline-area or line-area, A is an inline-area which is the last normal child of B, and S is the sequence consisting of the `space-end` of A.
3. A and B are each either an inline-area or a line-area, and either:
   - (a) both A and B are inline-areas, B is the next normal sibling area of A, and S is the sequence consisting of the `space-end` of A and the `space-start` of B;
   - (b) B is the first normal child of an inline-area P, P has no fence following A, A and P have an inline-stacking constraint S', the inline-progression-direction of P is the same as that of the nearest common ancestor area of A and P, and S consists of S' followed by the `space-start` of B;
   - (c) A is the last normal child of an inline-area P, P has no fence preceding B, P and B have an inline-stacking constraint S'', the inline-progression-direction of P is the same as that of the nearest common ancestor area of P and B, and S consists of the `space-end` of A followed by S'';
   - (d) B is the last normal child of an inline-area P, P has no fence following A, A and P have an inline-stacking constraint S', the inline-progression-direction of P is **opposite** to that of the nearest common ancestor area of A and P, and S consists of S' followed by the `space-end` of B;
   - (e) A is the first normal child of an inline-area P, P has no fence preceding B, P and B have an inline-stacking constraint S'', the inline-progression-direction of P is **opposite** to that of the nearest common ancestor area of P and B, and S consists of the `space-start` of A followed by S''.

When A and B have an inline-stacking constraint, the **adjacent edges** are:

- Case 1: the start-edge of the content-rectangle of A and the start-edge of the allocation-rectangle of B.
- Case 2: the end-edge of the allocation-rectangle of A and the end-edge of the content-rectangle of B.
- Case 3a: the end-edge of the allocation-rectangle of A and the start-edge of the allocation-rectangle of B.
- Case 3b: the first of the adjacent edges of A and P, and the start-edge of the allocation-rectangle of B.
- Case 3c: the end-edge of the allocation-rectangle of A and the second of the adjacent edges of P and B.
- Case 3d: the first of the adjacent edges of A and P, and the end-edge of the allocation-rectangle of B.
- Case 3e: the start-edge of the allocation-rectangle of A and the second of the adjacent edges of P and B.

Two areas are **adjacent** if they have a block-stacking constraint or an inline-stacking constraint. It follows that areas of the same type (inline or block) can be adjacent only if all their non-common ancestors are also of the same type (up to but not including their nearest common ancestor). Thus two inline-areas which reside in different line-areas are never adjacent.

An area A **begins** an area P if A is a descendant of P and P and A have either a block-stacking constraint or an inline-stacking constraint, provided that no descendant of P which is an ancestor of A has a `space-before` (block-stacking) or `space-start` (inline-stacking) whose computed minimum, maximum, or optimum values are nonzero. In this case, the second of the adjacent edges of P and A is defined to be a **leading edge** in P.

Similarly, an area A **ends** an area P if A is a descendant of P and A and P have either a block-stacking constraint or an inline-stacking constraint, provided that no descendant of P which is an ancestor of A has a `space-after` (block-stacking) or `space-end` (inline-stacking) whose computed minimum, maximum, or optimum values are nonzero. In this case, the first of the adjacent edges of A and P is defined to be a **trailing edge** in P.

## Block-areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-block -->

Block-areas have several traits that typically affect the placement of their children:

- **line-height**: used in line placement calculations.
- **line-stacking-strategy**: controls what kind of allocation is used for descendant line-areas; enumerated values are `font-height`, `max-height`, or `line-height`. All areas have these traits, but they only have relevance for areas which have stacked line-area children.
- **space-before** and **space-after**: determine the distance between the block-area and surrounding block-areas.

A block-area which is not a line-area typically has its size in the inline-progression-direction determined by its `start-indent` and `end-indent` and by the size of its nearest ancestor reference-area. A block-area which is not a line-area must be properly stacked unless otherwise specified in the description of its generating formatting object.

### Stacked Block-areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-stackblock -->

Block-area children of an area are typically stacked in the block-progression-direction within their parent area. This is the default method of positioning block-areas. However, formatting objects are free to specify other methods of positioning child areas (for example, list-items or tables).

For a parent area P whose children are block-areas, P is defined to be **properly stacked** if all of the following conditions hold:

1. For each block-area B which is a descendant of P:
   - The before-edge and after-edge of its allocation-rectangle are parallel to the before-edge and after-edges of the content-rectangle of P.
   - The start-edge of its allocation-rectangle is parallel to the start-edge of the content-rectangle of R (where R is the closest ancestor reference-area of B), and offset from it inward by a distance equal to the block-area's `start-indent` plus its `start-intrusion-adjustment`, minus its border-start, `padding-start`, and `space-start` values.
   - The end-edge of its allocation-rectangle is parallel to the end-edge of the content-rectangle of R, and offset from it inward by a distance equal to the block-area's `end-indent` plus its `end-intrusion-adjustment`, minus its border-end, `padding-end`, and `space-end` values.

   The notion of indent is intended to apply to the content-rectangle, but the constraint is written in terms of the allocation-rectangle, because the edges of the content-rectangle may not correspond to like-named edges of the allocation-rectangle.

2. For each pair of normal areas B and B' in the subtree below P, if B and B' have a block-stacking constraint S and B is not empty, then the distance between the adjacent edges of B and B' is consistent with the constraint imposed by the resolved values of the space-specifiers in S.

### Positioning in the Block-progression Direction

<!-- Source: https://www.w3.org/TR/xslfo20/#verticalpositioning -->

#### Feathering

<!-- Source: https://www.w3.org/TR/xslfo20/#feathering -->

Feathering is the process of fitting a block of text to available space, such as the height of the page, by adding a small (and ideally imperceptible) amount of space between each line of text. The formatter adjusts the `space-before` and `space-after` traits of the stacked block-areas and line-areas in order to fill the reference area.

Feathering can be seen as a special case of vertical justification, where the set of adjustable properties is fixed (`line-height`, `space-before`, and `space-after`).

Feathering is activated by setting the property `display-align` to "justify" and by listing the names `line-height`, `space-before`, `space-after` in the `adjustable-properties` property. The shorthand "feathering" can be used as a value for this property instead.

#### Correlating Position in the Block-progression Direction

<!-- Source: https://www.w3.org/TR/xslfo20/#correlating-vertical-position -->

To address position correlation across columns, a new property specifies a "normalized line height" that must be used as an atomic unit of height. That property specifies a length that the block-dimension of each generated area must be a multiple of. Spaces are added before or after each generated area in order to adjust the block-dimension. In a multi-column region, the same value is used for all columns.

The provisional name for this property is `block-unit`, whose value is a length.

#### Vertical Alignment within a Page or Column

<!-- Source: https://www.w3.org/TR/xslfo20/#column-vertical-alignment -->

The existing `display-align` property controls vertical alignment within a page or column. In a multi-column region, the same value is used for all columns, apart from the last one (specified with the property `display-align-last-column`).

Applies to: `fo:region-body`, `fo:region-before`, `fo:region-after`, `fo:region-start`, `fo:region-end`, and `fo:block-container`.

The `display-align` property also applies to: `fo:external-graphic`, `fo:instream-foreign-object`, `fo:inline-container`, and `fo:table-cell`.

#### Vertical Justification across Pages and Columns

<!-- Source: https://www.w3.org/TR/xslfo20/#pagecolumnverticaljustification -->

The `display-align` property is extended with a new value "justify". It is also important to allow users to specify which properties should be modified in order to do vertical justification. Feathering is one possibility. Other solutions include widening or narrowing spaces before and after images and tables, stretching or compressing text, changing word-spacing, adjusting the character-spacing, or other strategies.

The general approach of adjustable properties introduces a property `adjustable-properties` whose value is a list of properties that the formatter is allowed to change.

### Intrusion Adjustments

<!-- Source: https://www.w3.org/TR/xslfo20/#intrusadjust -->

Intrusion adjustments (both start- and end-) are defined to account for the indentation that occurs as the result of side floats.

If A and B are areas which have the same nearest reference area ancestor, then A and B are defined to be **inline-overlapping** if there is some line parallel to the inline-progression-direction which intersects both the allocation-rectangle of A and the allocation-rectangle of B.

**Start-encroachment**: If A is an area of class `xsl-side-float` with `float`=`start`, and B is a block-area with the same nearest reference area ancestor, then A **encroaches** upon B if A and B are inline-overlapping and the `start-indent` of B is less than the sum of the `start-indent` of A and the `inline-progression-dimension` of A. The **start-encroachment** is the amount by which the `start-indent` of B is less than that sum.

**End-encroachment**: Defined analogously for `float`=`end` areas using `end-indent`.

**Local-start-intrusion-adjustment** for a block-area B (not a line-area) is the maximum of:

1. Zero.
2. If the parent of B is not a reference area: the start-intrusion-adjustment of the parent of B.
3. If B has `intrusion-displace`=`block`, then for each `xsl-side-float` area A with `float`=`start` (where A's generating FO is not a descendant of B's generating FO) that encroaches upon some line-area child of B: the start-encroachment of A on B.
4. If B has `intrusion-displace`=`block`, then for each `xsl-side-float` area A with `float`=`start` that is inline-overlapping with B, and for each block-area ancestor B' of B within the nearest reference area ancestor, such that A encroaches on a line-area child of B': the start-encroachment of A on B'.

The **start-intrusion-adjustment** of a block-area B is the maximum of the local-start-intrusion-adjustments of the normal block-areas generated and returned by the generating formatting object of B.

For a **line-area** L, its start-intrusion-adjustment is the maximum of:

1. The start-intrusion-adjustment of the parent of L.
2. For each `xsl-side-float` area A with `float`=`start` that encroaches upon L: the start-encroachment of A on L.
3. If the parent of L has `intrusion-displace`=`indent`, then for each `xsl-side-float` area A with `float`=`start` inline-overlapping with L, and for each block-area ancestor B' of L within the nearest reference area: the start-encroachment of A on B'.

The end-intrusion-adjustment is computed in a precisely analogous manner using `float`=`end` and `end-indent`/`end-encroachment`.

## Line-areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-line -->

A line-area is a special type of block-area, generated by the same formatting object which generated its parent. Line-areas do not have borders and padding (i.e., `border-before-width`, padding-before-width, etc. are all zero). Inline-areas are stacked within a line-area relative to a **baseline-start-point**, which is a point determined by the formatter on the start-edge of the line area's content-rectangle.

The allocation-rectangle of a line is determined by the value of the `line-stacking-strategy` trait:

- **`font-height`**: the allocation-rectangle is the **nominal-requested-line-rectangle**.
- **`max-height`**: the allocation-rectangle is the **maximum-line-rectangle**.
- **`line-height`**: the allocation-rectangle is the **per-inline-height-rectangle**.

If the `line-stacking-strategy` trait is `font-height` or `max-height`, the `space-before` and `space-after` are both set to the half-leading value; otherwise they are both set to zero.

**Nominal-requested-line-rectangle**: the rectangle whose start-edge is parallel to and offset from the start-edge of the content-rectangle of the nearest ancestor reference-area by the sum of the `start-indent` and the start-intrusion-adjustment; whose end-edge is similarly offset from the end-edge by the sum of `end-indent` and end-intrusion-adjustment; whose before-edge is separated from the baseline-start-point by the `text-altitude` of the parent block-area; and whose after-edge is separated from the baseline-start-point by the `text-depth` of the parent block-area. It has the same `block-progression-dimension` for each line-area child of a block-area.

**Maximum-line-rectangle**: same start-edge and end-edge as the nominal-requested-line-rectangle, but whose extent in the block-progression-direction is the minimum required to enclose both the nominal-requested-line-rectangle and the allocation-rectangles of all the inline-areas stacked within the line-area. This may vary depending on the descendants of the line-area.

**Per-inline-height-rectangle**: same start-edge and end-edge as the nominal-requested-line-rectangle. Its extent in the block-progression-direction is determined using expanded-rectangles:

- The **expanded-rectangle** of an inline-area has start-edge and end-edge coincident with those of its allocation-rectangle, and whose before-edge and after-edge are outside those of its allocation-rectangle by a distance equal to either (a) the half-leading when the allocation-rectangle is the normal-allocation-rectangle, or (b) the `space-before` and `space-after` respectively when the allocation-rectangle is the large-allocation-rectangle.
- The **expanded-nominal-requested-line-rectangle** has start-edge and end-edge coincident with those of the nominal-requested-line-rectangle, with before-edge and after-edge outside by the half-leading.

The extent of the per-inline-height-rectangle is then the minimum required to enclose both the expanded-nominal-requested-line-rectangle and the expanded-rectangles of all the inline-areas stacked within the line-area.

Using the nominal-requested-line-rectangle allows equal baseline-to-baseline spacing. Using the maximum-line-rectangle allows constant space between line-areas. Using the per-inline-height-rectangle and zero `space-before`/`space-after` allows CSS-style line box stacking. The value of half-leading is included in the expanded-rectangle regardless of conditionality.

## Inline-areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-inline -->

An inline-area has its own `line-height` trait, which may be different from the `line-height` of its containing block-area. This may affect the placement of its ancestor line-area when the `line-stacking-strategy` is `line-height`. An inline-area has an `actual-baseline-table` for its `nominal-font`. It has a `dominant-baseline-identifier` trait which determines how its stacked inline-area descendants are to be aligned.

An inline-area may or may not have child areas, and if so it may or may not be a reference-area.

- **Inline-area without children**: dimensions of the content-rectangle are computed as specified by the generating formatting object.
- **Inline-area with block-area children**: dimensions computed as specified by the generating formatting object.
- **Inline-area with inline-area children**: content-rectangle extends from its dominant baseline by its `text-depth` in the block-progression-direction, and in the opposite direction by its `text-altitude`; in the inline-progression-direction it extends from the start-edge of the allocation-rectangle of its first child to the end-edge of the allocation-rectangle of its last child. The allocation-rectangle of such an inline-area is the same as its content-rectangle.

The allocation-rectangle of an inline-area without children is either the normal-allocation-rectangle or the large-allocation-rectangle, as specified by the generating formatting object.

When the `line-stacking-strategy` is `line-height`, allocation is done with respect to the expanded-rectangle.

### Stacked Inline-areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-stackinline -->

Inline-area children of an area are typically stacked in the inline-progression-direction within their parent area. Inline-areas are stacked relative to the **dominant baseline**.

For a parent area P whose children are inline-areas, P is defined to be **properly stacked** if all of the following conditions hold:

1. For each inline-area descendant I of P, the start-edge, end-edge, before-edge, and after-edge of the allocation-rectangle of I are parallel to corresponding edges of the content-rectangle of the nearest ancestor reference-area of I.
2. For each pair of normal areas I and I' in the subtree below P, if I and I' have an inline-stacking constraint S, then the distance between the adjacent edges of I and I' is consistent with the constraint imposed by the resolved values of the space-specifiers in S.
3. For any inline-area descendant I of P, the distance in the shift-direction from the dominant baseline of the parent Q of I, to the alignment-point of I equals the offset between the dominant baseline of Q and the baseline of Q corresponding to the `alignment-baseline` trait of I, plus the `baseline-shift` for I. The first summand compensates for mixed writing systems with different baseline types, and the other summands involve deliberate baseline shifts for things like superscripts and subscripts.

### Glyph-areas

<!-- Source: https://www.w3.org/TR/xslfo20/#area-glyph -->

The most common inline-area is a glyph-area, which contains the representation for a character (or characters) in a particular font.

A glyph-area has:

- An associated **nominal-font**, determined by the area's typographic traits which apply to its character data.
- A **glyph-orientation** determined by its `writing-mode` and `reference-orientation`, which determine the orientation of the glyph when rendered.

The alignment-point and dominant-baseline-identifier of a glyph-area are assigned according to the writing-system in use (e.g., the glyph baseline in Western languages), and are used to control placement of inline-area descendants of a line-area. The formatter may generate inline-areas with different inline-progression-directions from their parent to accommodate correct inline-area stacking in the case of mixed writing systems.

A glyph-area has no children. Its `block-progression-dimension` and actual-baseline-table are the same for all glyphs in a font. Conforming implementations may choose to compute the `block-progression-dimension` for a glyph area based on the actual glyph size rather than using a common size for all glyphs in a font.

### Font Baseline Tables

<!-- Source: https://www.w3.org/TR/xslfo20/#area-font -->

Each script has its preferred "baseline" for aligning glyphs from that script. Western scripts typically use an "alphabetic" baseline that touches at or near the bottom of capital letters. For each font there is a preferred way of aligning embedded glyphs from different scripts (e.g., for a Western font there are separate baselines for aligning embedded ideographic or Indic glyphs).

Each block-area and inline-area has a `dominant-baseline-identifier` trait whose value is a baseline identifier corresponding to the type of alignment expected for inline-area descendants, and each inline-area has an `alignment-baseline` which specifies how the area is aligned to its parent.

For each font, an `actual-baseline-table` maps baseline identifiers to points on the start-edge of the area. By abuse of terminology, the line in the inline-progression-direction through the point corresponding to the dominant-baseline-identifier is called the "dominant baseline."

## Ordering Constraints

<!-- Source: https://www.w3.org/TR/xslfo20/#area-order -->

### General Ordering Constraints

<!-- Source: https://www.w3.org/TR/xslfo20/#area-genorder -->

A subset S of the areas returned to a formatting object is called **properly ordered** if the areas in that subset have the same order as their generating formatting objects. Specifically, if A1 and A2 are areas in S, returned by child formatting objects F1 and F2 where F1 precedes F2, then A1 must precede A2 in the pre-order traversal order of the area tree. If F1 equals F2 and A1 is returned prior to A2, then A1 must precede A2 in the pre-order-traversal of the area tree.

For each formatting object F and each area-class C, the subset consisting of the areas returned to F with area-class C must be properly ordered, except where otherwise specified.

### Line-building

<!-- Source: https://www.w3.org/TR/xslfo20/#area-linebuild -->

This section describes the ordering constraints that apply to formatting an `fo:block` or similar block-level object.

A block-level formatting object F which constructs lines does so by constructing block-areas which it returns to its parent formatting object, and placing normal areas and/or anchor areas returned to F by its child formatting objects as children of those block-areas or of line-areas which it constructs as children of those block-areas.

For each such formatting object F, it must be possible to form an ordered partition P consisting of ordered subsets S1, S2, ..., Sn of the normal areas and anchor areas returned by the child formatting objects, such that the following are all satisfied:

1. Each subset consists of a sequence of inline-areas (and any associated annotation-areas), or of a single block-area.
2. The ordering of the partition follows the ordering of the formatting object tree. Specifically, if A is in Si and B is in Sj with i < j, or if A and B are both in the same subset Si with A before B in the subset order, then either A is returned by a preceding sibling formatting object of B, or A and B are returned by the same formatting object with A being returned before B.
3. The partitioning occurs at legal line-breaks. Specifically, if A is the last area of Si and B is the first area of Si+1, then the rules of the `language`, `script`, and hyphenation constraints must permit a line-break between A and B, within the context of all areas in Si and Si+1.
4. Forced line-breaks are respected. Specifically, if C is a descendant of F, and C is an `fo:character` whose Unicode character is U+000A, and A is the area generated by C, then either C is a child of F and A is the last area in a subset Si, or C is a descendant of a child C' of F, and A ends an area A' returned by C', such that A' is the last area in a subset Si.
5. The partition follows the ordering of the area tree, except for certain glyph substitutions and deletions. Specifically, if B1, B2, ..., Bp are the normal child areas of the area or areas returned by F (ordered in the pre-order traversal order of the area tree), then there is a one-to-one correspondence between these child areas and the partition subsets (i.e., n = p), and for each i:
   - Si consists of a single block-area and Bi is that block-area, or
   - Si consists of inline-areas and Bi is a line-area whose child areas are the same as the inline-areas in Si, and in the same order, except that where the rules of the `language` and `script` in effect call for glyph-areas to be substituted, inserted, or deleted, the substituted or inserted glyph-areas appear in the area tree in the corresponding place, and the deleted glyph-areas do not appear. Insertions and substitutions may occur because of addition of hyphens, spelling changes due to hyphenation, glyph image construction from syllabification, or ligature formation.
6. `white-space-treatment` is enforced. Deletions occur when there is a glyph area G such that:
   - (a) the `white-space-treatment` of G is "ignore" and the character of G is classified as white space in XML; or
   - (b) the `white-space-treatment` of G is "ignore-if-before-linefeed" or "ignore-if-surrounding-linefeed", the `suppress-at-line-break` of G is "suppress", and G would end a line-area; or
   - (c) the `white-space-treatment` of G is "ignore-if-after-linefeed" or "ignore-if-surrounding-linefeed", the `suppress-at-line-break` of G is "suppress", and G would begin a line-area.

Substitutions that replace a sequence of glyph-areas with a single glyph-area should only occur when the margin, border, and padding in the inline-progression-direction, `baseline-shift`, and `letter-spacing` values are zero, `treat-as-word-space` is `false`, and the values of all other relevant traits match (i.e., `alignment-adjust`, `alignment-baseline`, color trait, background traits, dominant-baseline-identifier, font traits, `text-depth`, `text-altitude`, `glyph-orientation-horizontal`, `glyph-orientation-vertical`, `line-height`, `line-height-shift-adjustment`, `text-decoration`, `text-shadow`).

Line-areas do not receive the background traits or text-decoration of their generating formatting object, or any other trait that requires generation of a mark during rendering.

### Inline-building

<!-- Source: https://www.w3.org/TR/xslfo20/#area-inlinebuild -->

This section describes the ordering constraints that apply to formatting an `fo:inline` or similar inline-level object.

An inline-level formatting object F which constructs one or more inline-areas does so by placing normal inline-areas and/or anchor inline-areas and/or annotation-areas returned to F by its child formatting objects as children of inline-areas which it generates.

For each such formatting object F, it must be possible to form an ordered partition P consisting of ordered subsets S1, S2, ..., Sn of the normal and/or anchor inline-areas and normal block-areas returned by the child formatting objects, such that the following are all satisfied:

1. Each subset consists of a sequence of inline-areas, or of a single block-area.
2. The ordering of the partition follows the ordering of the formatting object tree, as defined above.
3. The partitioning occurs at legal line-breaks, as defined above.
4. Forced line-breaks are respected, as defined above.
5. The partition follows the ordering of the area tree, except for certain glyph substitutions and deletions, as defined above.

## Rendering Model (Subsections)

### Geometry

<!-- Source: https://www.w3.org/TR/xslfo20/#rend-geo -->

Each area is rendered in a particular location. Formatting object semantics describe the location of intrinsic marks relative to the object's location (i.e., the left, right, top, and bottom edges of its content-rectangle).

- For each page, the **page-viewport-area** corresponds isometrically to the output medium.
- The **page-reference-area** is offset from the page-viewport-area as described under Viewport Geometry.
- All areas with an area-class of `xsl-fixed` are positioned such that the left-, right-, top-, and bottom-edges of its content-rectangle are offset inward from the content-rectangle of its ancestor page-viewport-area by distances specified by the `left-position`, `right-position`, `top-position`, and `bottom-position` traits.
- Any area which is the child of a viewport-area is rendered as described under Viewport Geometry.
- All other areas are positioned such that the left-, right-, top-, and bottom-edges of its content-rectangle are offset inward from the content-rectangle of its nearest ancestor reference-area by distances specified by the `left-position`, `right-position`, `top-position`, and `bottom-position` traits. These are shifted down and left by the values of the `top-offset` and `left-offset` traits, respectively, if the area has a `relative-position` of `relative`.

### Viewport Geometry

<!-- Source: https://www.w3.org/TR/xslfo20/#rend-view -->

A reference-area which is the child of a viewport-area is positioned such that the start-edge and end-edge of its content-rectangle are parallel to the start-edge and end-edge of the content-rectangle of its parent viewport-area. The start-edge of its content-rectangle is offset from the start-edge of the content-rectangle of its parent viewport-area by an **inline-scroll-amount**, and the before-edge of its content-rectangle is offset from the before-edge by a **block-scroll-amount**.

If the `block-progression-dimension` of the reference-area is larger than that of the viewport-area and the `overflow` trait for the reference-area is `scroll`, then the inline-scroll-amount and block-scroll-amount are determined by a scrolling mechanism, if any, provided by the user agent. Otherwise, both are zero.

### Visibility

<!-- Source: https://www.w3.org/TR/xslfo20/#rend-vis -->

The visibility of marks depends upon the location of the marks, the `visibility` of the area, and the `overflow` of any ancestor viewport-areas.

- If an area has `visibility` `hidden`, it generates no marks.
- If an area has an `overflow` of `hidden`, or when the environment is non-dynamic and the `overflow` is `scroll`, then the area determines a **clipping rectangle** (defined by the value of the `clip` trait), and for any mark generated by one of its descendant areas, portions of the mark lying outside the clipping rectangle do not appear.

### Border, Padding, and Background

<!-- Source: https://www.w3.org/TR/xslfo20/#rend-border -->

The border- and padding-rectangles are determined relative to the content-rectangle by the values of the common padding and border width traits (`border-before-width`, etc.).

- For any area which is **not** a child of a viewport-area, the border is rendered between the border-rectangle and the padding-rectangle in accordance with the common border color and style traits.
- For a child of a viewport-area, the border is **not** rendered.
- For an area that is not part of a viewport/reference pair, the background is rendered.
- For an area that is either a viewport-area or a reference-area in a viewport/reference pair: if the refined value of `background-attachment` is `scroll` and the `block-progression-dimension` of the reference-area is larger than that of the viewport-area, then the background is rendered on the reference-area and not the viewport-area; otherwise it is rendered on the viewport-area and not the reference-area.
- The background, if any, is rendered in the padding-rectangle, in accordance with the `background-image`, `background-color`, `background-repeat`, `background-position-vertical`, and `background-position-horizontal` traits.

### Intrinsic Marks

<!-- Source: https://www.w3.org/TR/xslfo20/#rend-intrinsic -->

For each class of formatting objects, the marks intrinsic to its generated areas are specified in the formatting object description. For example, an `fo:character` object generates a glyph-area, and this is rendered by drawing a glyph within that area's content-rectangle in accordance with the area's font traits and `glyph-orientation` and `blink` traits.

In addition, other traits (for example the various score and score-color traits) specify other intrinsic marks. In the case of score traits (`underline-score`, `overline-score`, and `through-score`), the score thickness and position are specified by the nominal-font in effect; where the font fails to specify these quantities, they are implementation-dependent.

### Layering and Conflict of Marks

<!-- Source: https://www.w3.org/TR/xslfo20/#rend-layer -->

Marks are layered according to a partial ordering that defines which marks are **beneath** which other marks.

Two marks are defined to **conflict** if they apply to the same point in the output medium. When two marks conflict, the one which is beneath the other does not affect points in the output medium where they both apply.

**Within the same area**, marks are layered as follows: the area background is beneath the area's intrinsic marks, and the intrinsic marks are beneath the border. Layering among the area's intrinsic marks is defined by the semantics of the area's generating formatting object. For example, a glyph-area's glyph drawing comes beneath the marks generated for text-decoration.

**Between areas**, the stacking layer is defined by the stacking context and the `z-index` value. The stacking layer of an area A is defined to be less than that of an area B if some ancestor-or-self A' of A and B' of B have the same stacking context and the `z-index` of A' is less than the `z-index` of B'.

- If the stacking layer of A is less than the stacking layer of B, then all marks generated by A are beneath all marks generated by B.
- If A and B have the same stacking layer, the backgrounds of A and B come beneath all other marks generated by A and B. If A is an ancestor of B (with the same stacking layer), then the background of A is beneath all the areas of B, and all the areas of B are beneath the intrinsic areas (and border) of A.
- If A and B have the same stacking layer and neither is an ancestor of the other, then it is an error if either their backgrounds conflict or if a non-background mark of A conflicts with a non-background mark of B. An implementation may recover by proceeding as if the marks from the first area in pre-order traversal order are beneath those of the other area.

## Sample Area Tree

<!-- Source: https://www.w3.org/TR/xslfo20/#area-tree-sample -->

The spec provides a diagram of a typical area tree showing (as nodes) viewports and reference areas from pages, regions, floats, footnotes, and the main flow.

## Copyfitting Summary

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-summary -->

The copyfitting mechanism allows fitting content to a fixed area by adjusting certain properties. Key aspects:

- Copyfitting is allowed on `fo:region`, `fo:region-*` objects, `fo:block-container`, and `fo:table-cell`.
- A new value "justify" for the property `display-align` activates copyfitting. The property `force-page-count` (along with correct definitions of page-masters and page-sequences) helps avoid conflicts with vertical justification.
- The concept of a "list of prioritized adjustable properties" is introduced. An adjustable property is an existing XSL-FO property that can be modified for copyfitting or vertical justification.
- Range values of existing properties (using `.minimum`, `.optimum`, `.maximum` components) specify how and how much each property can be adjusted, introducing the idea of "elasticity".
- A new property `adjustable-properties` specifies such lists.
- New values for the property `force-page-count` model copyfit into a fixed number of pages or a multiple of a number.
- A new formatting object `fo:alternative-copyfit-content` expresses alternative content for copyfitting.

## Copyfit: Basic Approach and Definitions

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->

Copyfitting requires two logically separated tasks: (1) the request of copyfitting to a given area, and (2) the definition of strategies to copyfit.

Copyfitting is enabled by setting the property `display-align` to the value "justify". Copyfitting strategies are then expressed through "adjustable properties lists" using the `adjustable-properties` property.

Although the same approach is used for vertical justification, users can exploit the property `force-page-count` and/or the definition of page-masters and page-sequences to avoid conflicts.

The `display-align` property applies to `fo:region`, `fo:region-*`, `fo:block-container`, and `fo:table-cell`. It is possible to copyfit content in a block-container or in a table cell, and also to copyfit the content of one flow to a single region, multiple flows to a single region, or even multiple flows to multiple regions.

A `display-align-last` property is also added, to specify different treatment of the last page in a copyfitted sequence, by analogy with `text-align` and `text-align-last`.

## Copyfit Examples

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->

### Example 1: Two Flows to Two Distinct Regions

Two flows A and B go into two distinct regions R1 and R2. The property `display-align` on `fo:region` activates copyfit for region R1. No copyfit is activated on region R2 since `display-align` has value "before". The property `force-page-count` on `fo:page-sequence` states that the overall content has to be copyfitted in one page. The property `adjustable-properties` lists those XSL-FO properties that can be modified to copyfit text.

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->
```xml
<?xml version="1.0" encoding="UTF-8"?>
<fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
<fo:page-master master-name="sample1"
     page-height="11in" page-width="8.5in" margin-top="3pt"
     margin-bottom="3pt" margin-left="3pt" margin-right="3pt">
  <fo:region  region-name="R1"
     display-align="justify"
     adjustable-properties="line-height"/>
  <fo:region  region-name="R2"
     display-align="before"/>
</fo:page-master>

<fo:flow-map flow-map-name="M1">
  <fo:flow-assignment>
    <fo:flow-source-list>
       <fo:flow-name-specifier flow-name-reference="A"/>
    </fo:flow-source-list>
    <fo:flow-target-list>
     <fo:region-name-specifier region-name-reference="R1"/>
    </fo:flow-target-list>
   </fo:flow-assignment>
   <fo:flow-assignment>
    <fo:flow-source-list>
     <fo:flow-name-specifier flow-name-reference="B"/>
    </fo:flow-source-list>
    <fo:flow-target-list>
     <fo:region-name-specifier region-name-reference="R2"/>
    </fo:flow-target-list>
    </fo:flow-assignment>
 </fo:flow-map>

<fo:page-sequence force-page-count="1" flow-map-reference="M1">
  <fo:flow flow-name="A">
   <fo:block> Lorem maecenas blandit ac, neque sed ut pulvinar,
   lectus sagittis sapien per risus vel.  Ligula sapien sed morbi cras
   tellus commodo. Si qua ex docet dei etris crucis</fo:block>
  <fo:block> curabitur magna nisi, faucibus sed ornare sed,
  congue eu dui.  Pellentesque habitant morbi tristique senectus et
  netus et malessecularia uada fames ac turpis
  egestas. </fo:block>
  <fo:block> Nunc sit amet dolor sed sem congue mattis sed ut
  arcu. Mauris id magna sit amet elit aliquam.</fo:block>
  <fo:block>Pellentesque habitant morbi tristique senectus et
  netus et malesuada fames.</fo:block>
 </fo:flow>

 <fo:flow flow-name="B">
  <fo:block>Crucis rosa ut hoc sien qua non res veni.</fo:block>
  <fo:block> Etiam tristique, nulla a pulvinar hendrerit nihil
  tortor urna auctor etim domine secularia cali sed ut quotie ire in
  domince hoc fantus quis eius rei rei.  </fo:block>
</fo:flow>
</fo:page-sequence>
</fo:root>
```

### Example 2: Two Flows Mapped to Both Regions

The same flows and regions produce a different output when a flow-map maps both flows A and B to both regions R1 and R2. In this case, the two flows go into region R1 and then region R2.

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->
```xml
<fo:flow-map flow-map-name="M2">
<fo:flow-assignment>
<fo:flow-source-list>
<fo:flow-name-specifier flow-name-reference="A"/>
<fo:flow-name-specifier flow-name-reference="B"/>
</fo:flow-source-list>
<fo:flow-target-list>
<fo:region-name-specifier region-name-reference="R1"/>
<fo:region-name-specifier region-name-reference="R2"/>
</fo:flow-target-list>
</fo:flow-assignment>
</fo:flow-map>
```

### Example 3: Both Regions with display-align="justify"

The expected result is different when the property `display-align` of region R2 is also set to "justify". Both regions end up being copyfitted.

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->
```xml
<fo:page-master master-name="sample1"
   page-height="11in" page-width="8.5in" margin-top="3pt"
   margin-bottom="3pt" margin-left="3pt" margin-right="3pt">
  <fo:region  region-name="R1"
     display-align="justify"
     adjustable-properties="line-height"/>
    <fo:region  region-name="R2"
      display-align="justify"/>
  </fo:page-master>
```

### Example 4: Vertical Justification with display-align-last

When the formatter is expected to produce as many pages as needed (e.g., `force-page-count` set to "no-force"), the property `display-align` activates vertical justification. The property `display-align-last` then sets the vertical alignment of the last page.

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->
```xml
<?xml version="1.0" encoding="UTF-8"?>
<fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
 <fo:page-master master-name="sample1"
    page-height="11in" page-width="8.5in" margin-top="3pt"
   margin-bottom="3pt" margin-left="3pt" margin-right="3pt">
  <fo:region-body region-name="xsl-region-body"
    display-align="justify"
    display-align-last="relative"
    adjustable-properties="..."/>
</fo:page-master>

<fo:page-sequence>
  <fo:flow flow-name="A">

<fo:block>Lorem ipsum dolor sit amet, nunc euismod nisl nam euismod, quis maecenas
blandit ac, neque sed ut pulvinar, lectus sagittis ... quorneque tortor
neque, commodo mauris sagittis yurpis,hic fecit leuc em.</fo:block>

<fo:block>Lorem ipsum dolor sit amet, nunc ... lectus sagittis sapien
mauris per risus.</fo:block>

<fo:block>Ligula sapien sed morbi cras tellus ... quoque
cra ut sic fecit quorem deis hoc hac lorem ipse die cruci faucibus sed ultrices
tempor inter dum.</fo:block>
<fo:block>Lorem ipsum dolor sit amet, .... Rutrum mattis accumsan.</fo:block>
</fo:flow>
</fo:page-sequence>
</fo:root>
```

The values of `display-align` ("justify") and `display-align-last` ("relative") on `fo:region-body` require the formatter to vertically justify the first two pages while allowing the last page to be partially filled. By setting `display-align-last` to "justify", the last page is also vertically justified.

### Example 5: Fixed Number of Pages with force-page-count

The formatter is expected to copyfit text in a given number of pages when the property `force-page-count` is set to an integer value.

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->
```xml
<fo:region-body region-name="xsl-region-body"
display-align="justify"
display-align-last="justify"
 force-page-count="2"
adjustable-properties="..."/>
```

The last page is vertically justified since `display-align-last` is set to "justify". By changing that property, the user can obtain the same number of pages without requiring the last one to be completely filled.

## Content Adjusting Strategies

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->

XSL-FO provides a general mechanism to express strategies for copyfitting or vertical justification. The overall approach is flexible and independent of the formatting task and may be applied to other contexts in the future.

An **adjustable properties list** is an ordered sequence of property names (or groups of names) that a formatter is allowed to modify to format the content. Such lists are used to drive copyfitting, vertical justification, and feathering. The order of the names in the list follows priority rules.

Adjustable properties lists can be associated with FO objects using the property `adjustable-properties`.

The "adjustable-properties list" only states the strategy to format the content and does not define the actual property ranges the application is allowed to modify. These are instead expressed throughout the flow and its descendant formatting objects using the standard range notation (`.minimum`, `.optimum`, `.maximum` components). This provides great expressive power, as it allows different `fo:block` elements to have different adjusting properties.

For example: `adjustable-properties="space-before word-spacing"` means the application is allowed to modify the actual value of the `space-before` and `word-spacing` properties, choosing values between the `.minimum` and `.maximum` specified on the blocks within the flow.

**Elasticity**: A property having a range value can create some elasticity -- the dimensions of the areas generated by the affected formatting objects can stretch or shrink from an optimal value.

- **Inline elasticity**: properties involved in the line building process that have some degree of elasticity.
- **Block elasticity**: properties involved in the block stacking process that have some degree of elasticity.

A length range in an inline-related property can involve both inline and block elasticity (e.g., a variation in `word-spacing` may result in the creation of fewer or more lines), while a range in a block-related property only creates block elasticity.

The presence of some elasticity is the first condition to adjust content. If properties listed in the "adjustable properties list" do not have elasticity while others do, the formatter cannot achieve the expected result and should warn the user. If properties do have elasticity but the formatter is still not able to achieve the expected result (due to syntax errors, limited support, etc.), the formatter should warn the user as well.

### Example 6: Copyfit with word-spacing and line-height Ranges

<!-- Source: https://www.w3.org/TR/xslfo20/#copyfitting-approach -->
```xml
<?xml version="1.0" encoding="UTF-8"?>
<fo:root xmlns:fo="http://www.w3.org/1999/XSL/Format">
  <fo:page-master master-name="sample1" page-height="11in"
        page-width="8.5in" margin-top="3pt"
	margin-bottom="3pt" margin-left="3pt" margin-right="3pt">
   <fo:region  region-name="R1"
       display-align="justify"
       adjustable-properties="line-height"/>
   <fo:region  region-name="R2"
       display-align="before"/>
</fo:page-master>

<fo:flow-map flow-map-name="M1">
  <fo:flow-assignment>
    <fo:flow-source-list>
     <fo:flow-name-specifier flow-name-reference="A"/>
    </fo:flow-source-list>
    <fo:flow-target-list>
     <fo:region-name-specifier region-name-reference="R1"/>
    </fo:flow-target-list>
  </fo:flow-assignment>

  <fo:flow-assignment>
   <fo:flow-source-list>
    <fo:flow-name-specifier flow-name-reference="B"/>
   </fo:flow-source-list>
   <fo:flow-target-list>
     <fo:region-name-specifier region-name-reference="R2"/>
   </fo:flow-target-list>
  </fo:flow-assignment>
</fo:flow-map>

<fo:page-sequence force-page-count="1" flow-map-reference="M1">
  <fo:flow flow-name="A">

  <fo:block word-spacing.minimum="1pt" word-spacing.maximum="4pt"
  line-height.minimum="8pt" line-height.maximum="14pt"> Lorem
  maecenas blandit ac, neque sed ut pulvinar, lectus sagittis sapien
  per risus vel.  Ligula sapien sed morbi cras tellus commodo.  Si qua
  ex docet dei etris crucis</fo:block>

  <fo:block word-spacing.minimum="1pt" word-spacing.maximum="4pt"
  line-height.minimum="8pt" line-height.maximum="14pt"> curabitur
  magna nis, faucibus sed ornare sed, congue eu dui.  Pellentesque
  habitant morbi tristique senectus et netus et malessecularia uada
  fames ac turpis egestas. </fo:block>

  <fo:block word-spacing.minimum="1pt" word-spacing.maximum="4pt"
  line-height.minimum="8pt" line-height.maximum="14pt"> Nunc sit
  amet dolor sed sem congue mattis sed ut arcu. Mauris id magna sit
  amet elit aliquam.</fo:block> <fo:block>Pellentesque
  habitant morbi tristique senectus et netus et malesuada
  fames.</fo:block>

  </fo:flow>
  <fo:flow flow-name="B">

  <fo:block word-spacing.minimum="1pt" word-spacing.maximum="4pt"
  line-height.minimum="8pt" line-height.maximum="14pt">Crucis rosa
  ut hoc sien qua non res veni.</fo:block>

  <fo:block word-spacing.minimum="1pt" word-spacing.maximum="4pt"
  line-height.minimum="8pt" line-height.maximum="14pt"> Etiam
  tristique, nulla a pulvinar hendrerit nihil tortor urna auctor etim
  domine secularia cali sed ut quotie ire in domince hoc fantus quis
  eius rei rei.  </fo:block>

</fo:flow>
</fo:page-sequence>
</fo:root>
```

The two regions R1 and R2 use different strategies to copyfit. Flow A is copyfitted into region R1 by only adjusting the word-space of each block (that will be a value between 1pt and 4pt), while flow B is copyfitted into region R2 by adjusting line-height of each block (that will be a value between 8pt and 14pt).

The declaration of strategies for copyfitting is completely disconnected from the declaration of the copyfit itself. The definition of `adjustable-properties` in a `fo:flow-assignment` object provides great flexibility; different blocks may have different values of the same property that are all within the allowed ranges. Current typographic practice would tend to use the available elasticity with uniformity within the same page-sequence or at least within the same page.

## See Also

- `guide-spaces-conditionality.md` -- Spaces and Conditionality (space resolution rules, conditional borders and padding)
- `guide-keeps-breaks.md` -- Keeps and Breaks (keep and break conditions on areas)
- `guide-rendering-model.md` -- Rendering Model (full rendering model coverage)
- `guide-copyfitting.md` -- Copyfitting (full copyfitting coverage)
- `fo-block.md` -- `fo:block` formatting object
- `fo-inline.md` -- `fo:inline` formatting object
- `fo-page-sequence.md` -- `fo:page-sequence` formatting object
- `properties-pagination.md` -- Pagination and layout properties
