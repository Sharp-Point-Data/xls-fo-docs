# Unicode Bidirectional (BIDI) Processing

## Overview

Characters in certain scripts (notably Arabic and Hebrew) are written horizontally from right to left. In mixed-language documents, text within a single visually displayed block may contain both left-to-right and right-to-left runs -- a phenomenon called **bidirectionality**, or "BIDI" for short. XSL-FO applies the Unicode Bidirectional Algorithm to resolve the directionality of mixed text and represent the result as explicit formatting object markup using `fo:bidi-override`, the `direction` property, and the `unicode-bidi` property.

This section describes how the Unicode BIDI algorithm is adapted to the XSL processing model during the refinement step of formatting.

<!-- Source: xslspec.xml line 4693 -->

## The Unicode BIDI Algorithm in XSL-FO

The Unicode BIDI algorithm (Unicode Technical Report #9) defines a complex algorithm for determining the proper directionality of text. The algorithm is based on both an **implicit** part derived from character properties, and **explicit** controls for embeddings and overrides.

During refinement, the algorithm converts the implicit directionality of text into explicit markup in terms of formatting objects. For example, a sub-sequence of Arabic characters in an otherwise English paragraph would cause the creation of an inline formatting object with the Arabic characters as its content, with a `direction` property of `rtl` and a `unicode-bidi` property of `bidi-override`. The formatting object makes explicit the previously implicit right-to-left positioning of the Arabic characters.

### Three Phases of the Algorithm

The Unicode BIDI algorithm takes a stream of text as input and proceeds in three main phases:

1. **Separation into paragraphs.** The rest of the algorithm affects only the text between paragraph separators.
2. **Resolution of embedding levels.** The bidirectional character types, plus the Unicode directional formatting codes, are used to produce **resolved embedding levels**. The normative bidirectional character type for each character is specified in the Unicode Character Database.
3. **Reordering for display.** The text is reordered on a line-by-line basis using the resolved embedding levels, once the text has been broken into lines.

## Adaptations to the XSL Processing Model

The algorithm as described above requires adaptations to fit into the XSL processing model.

### Text Reordering is Deferred

The final text reordering step is not done during refinement. Instead, the XSL equivalent of reordering is done during area tree generation. The `inline-progression-direction` of each glyph is used to control the stacking of glyphs as described in the area stacking constraints. The `inline-progression-direction` is determined at the block level by the `writing-mode` property and within inline formatting objects by the `direction` and `unicode-bidi` properties that were either specified on inline formatting objects generated by tree construction or are on inline formatting objects introduced by the refinement step.

### Flattened Sequence of Characters

The algorithm is applied to a sequence of characters coming from the content of one or more formatting objects. The sequence is created by processing a **fragment** of the formatting object tree -- any contiguous sequence of children of some formatting object. The sequence is built by doing a pre-order traversal of the fragment down to the `fo:character` level:

- Every `fo:character` formatting object adds a character to the sequence.
- Whenever the pre-order scan encounters a node with a `unicode-bidi` property with a value of `embed` or `bidi-override`, a Unicode RLO/LRO or RLE/LRE character is added to the sequence as appropriate to the value of the `direction` and `unicode-bidi` properties.
- On returning to that node after traversing its content, a Unicode PDF character is added.

The resulting sequence is called the **flattened sequence of characters**.

### Delimited Text Ranges

In XSL, the algorithm is applied to **delimited text ranges** instead of just paragraphs. A delimited text range is a maximal flattened sequence of characters that does not contain any delimiters. The following act as delimiters:

- Any formatting object that generates **block-areas** acts as a delimiter for its content and for its parent's content. If the parent has character content, its children formatting objects that generate block-areas break that character content into **anonymous blocks**, each of which is a delimited text range.
- The `fo:multi-case` formatting object acts as a delimiter for its content and the content of its parent.
- Text with an orientation that is not perpendicular to the `dominant-baseline` acts as a delimiter to text with an orientation perpendicular to the dominant-baseline.

In most cases, a delimited text range is the maximal sequence of characters that would be formatted into a sequence of one or more line-areas. For `fo:multi-case` and text with an orientation perpendicular to the `dominant-baseline`, the delimited range may be a sub-sequence of a line or sequence of lines. For example, in Japanese formatted in a vertical writing-mode, rotated Latin and Arabic text would be delimited by the vertical Japanese characters that immediately surround the Latin and Arabic text. Any formatting objects that generated inline-areas would have no effect on the determination of the delimited text range.

## Paragraph Embedding Level

For each delimited text range, the `inline-progression-direction` of the nearest ancestor (including self) formatting object that generates a block-area determines the **paragraph embedding level** used in the Unicode BIDI algorithm. This is the default embedding level for the delimited text range.

**Embedding levels** are numbers that indicate how deeply the text is nested, and the default direction of text on that level. The minimum embedding level is zero and the maximum embedding level is 61. Having more than 61 embedding levels is an error. An XSL processor may signal the error. If it does not signal the error, it must recover by allowing a higher maximum number of embedding levels.

## Resolved Embedding Levels

The second step of the Unicode BIDI algorithm labels each character in the delimited text range with a **resolved embedding level**. The resolved embedding level of each character will be greater than or equal to the paragraph embedding level. Right-to-left text will always end up with an odd level, and left-to-right and numeric text will always end up with an even level. In addition, numeric text will always end up with a higher level than the paragraph level.

## Insertion of fo:bidi-override Formatting Objects

Once the resolved embedding levels are determined for the delimited text range, new `fo:bidi-override` formatting objects with appropriate values for the `direction` and `unicode-bidi` properties are inserted into the formatting object tree fragment that was flattened into the delimited text range. The following constraints must be satisfied:

1. **Direction matches resolved level.** For any character in the delimited text range, the `inline-progression-direction` of the character must match its resolved embedding level.

2. **Proper nesting at each level.** For each resolved embedding level L from the paragraph embedding level to the maximum resolved embedding level, and for each maximal contiguous sequence of characters S for which the resolved embedding level of each character is greater than or equal to L:
   - There is an inline formatting object F which has as its content the formatting object tree fragment that flattens to S and has a `direction` property consistent with the resolved embedding level L. (F need not be an inserted formatting object if the constraint is met by an existing formatting object or by specifying values for the `direction` and `unicode-bidi` properties on an existing formatting object.)
   - All formatting objects that contain any part of the sequence S are properly nested in F and retain the nesting relationships they had in the formatting object tree prior to the insertion of the new formatting objects.

3. **Minimality.** No fewer `fo:bidi-override` formatting objects can be inserted and still satisfy the above constraints. That is, add to the refined formatting object tree only as many `fo:bidi-override` formatting objects, beyond the formatting objects created during tree construction, as are needed to represent the embedding levels present in the document.

### Splitting of Existing Formatting Objects

Satisfying the nesting constraint may require splitting one or more existing formatting objects in the formatting object tree each into a pair of formatting objects, each of which has the same set of computed property values as the original, unsplit formatting object. One of the pair would be ended before the start of F or start after the end of F, and the other would start after the start of F or would end before the end of F, respectively. The created pairs must continue to nest properly. Only the first member of the pair retains the original `id` value, since `id` values must be unique within the formatting object tree.

## Code Samples

The following examples illustrate how the BIDI refinement process splits existing formatting objects and inserts `fo:bidi-override` elements. Assume left-to-right text is represented by the character "L" and right-to-left text is represented by "R".

Given the sub-tree:

<!-- Source: xslspec.xml line 4878 -->
```xml
  <fo:block>
    LL
    <fo:inline id="A" color="red">LLLRRR</fo:inline>
    RR
  </fo:block>
```

Assuming a paragraph embedding level of "0", the resolved embedding levels would require the following (inserted and replicated) structure:

<!-- Source: xslspec.xml line 4888 -->
```xml
   <fo:block>
    LL
    <fo:inline id="A" color="red">LLL</fo:inline>
    <fo:bidi-override direction="rtl">
      <fo:inline color="red">RRR</fo:inline>
      RR
    </fo:bidi-override>
  </fo:block>
```

Note that the `fo:inline` with `id` equal to "A" has been split into two `fo:inline` elements, with only the first one retaining the original `id` of "A". Since `id` values must be unique within the formatting object tree, the computed value of any `id` must not be replicated in the second member of the pair.

## See Also

- [fo:bidi-override](fo-bidi-override.md) -- The BIDI override formatting object used to explicitly control directionality
- [Writing Modes Guide](guide-writing-modes.md) -- Writing mode concepts including block-progression-direction and inline-progression-direction
- [Writing-Mode Properties](properties-writing-mode.md) -- Properties controlling writing-mode, direction, and unicode-bidi
